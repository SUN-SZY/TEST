<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<link rel="stylesheet" href="/_assets/main.css" />

    <title>第二课 STL - SUN</title>
  <link rel="stylesheet" href="/_markdown_plugin_assets/katex/katex.css" />
<link rel="stylesheet" href="/_markdown_plugin_assets/highlight.js/atom-one-light.css" /><style>.mermaid { background-color: white; width: 640px; }</style></head>
  <body>
    <div class="main">
      <nav class="navigation">
        <a href="/">SUN</a>
      </nav>
      <article>
        <header>
          <h1 class="article-title">第二课 STL</h1>
          <div class="article-info">
            <div>
              <span
                >Created At：<time datetime="1645757754692"
                  >2022-02-25 10:55</time
                ></span
              >
              <span
                >Updated At：<time datetime="1645795511643"
                  >2022-02-25 21:25</time
                ></span
              >
            </div>
            
          </div>
        </header>
        <div class="article-content markdown-body"><nav class="table-of-contents"><ul><li><a href="#算法设计工具stl">算法设计工具——STL</a><ul><li><a href="#什么是stl容器">什么是STL容器</a></li><li><a href="#什么是stl算法">什么是STL算法</a><ul><li><a href="#例如以下程序使用stl算法sort实现整型数组a的递增排序">例如，以下程序使用STL算法sort()实现整型数组a的递增排序：</a></li></ul></li><li><a href="#什么是stl迭代器">什么是STL迭代器</a><ul><li><a href="#常见的迭代器">常见的迭代器</a></li><li><a href="#常见的迭代器运算">常见的迭代器运算</a></li><li><a href="#常见的stl容器">常见的STL容器</a><ul><li><a href="#顺序容器">顺序容器</a><ul><li><a href="#vector向量容器">vector（向量容器）</a></li><li><a href="#string字符串容器">string（字符串容器）</a></li><li><a href="#deque双端队列容器">deque（双端队列容器）</a></li><li><a href="#list链表容器">list（链表容器）</a></li></ul></li><li><a href="#关联容器">关联容器</a><ul><li><a href="#set集合容器-multiset多重集容器">set（集合容器）/ multiset（多重集容器）</a></li><li><a href="#map映射容器-multimap多重映射容器">map（映射容器）/ multimap（多重映射容器）</a></li></ul></li><li><a href="#适配器容器">适配器容器</a><ul><li><a href="#stack栈容器">stack（栈容器）</a></li><li><a href="#queue队列容器">queue（队列容器）</a></li><li><a href="#3priority_queue优先队列容器">3）priority_queue（优先队列容器）</a></li></ul></li></ul></li></ul></li></ul></li><li><a href="#stl在算法设计中的应用">STL在算法设计中的应用</a><ul><li><a href="#存放主数据">存放主数据</a></li><li><a href="#存放临时数据">存放临时数据</a></li><li><a href="#检测数据元素的唯一性">检测数据元素的唯一性</a></li><li><a href="#数组排序">数组排序</a><ul><li><a href="#内置数据类型的排序">内置数据类型的排序</a></li><li><a href="#自定义数据类型的排序">自定义数据类型的排序</a></li></ul></li><li><a href="#优先队列作为堆">优先队列作为堆</a><ul><li><a href="#元素为内置数据类型的堆">元素为内置数据类型的堆</a></li><li><a href="#元素为自定义类型的堆">元素为自定义类型的堆</a></li></ul></li></ul></li><li><a href="#补充知识">补充知识</a></li></ul></nav><h1 id="算法设计工具stl">算法设计工具——STL</h1>
<p>STL主要由container（容器）、algorithm（算法）和iterator（迭代器）三大部分构成，容器用于存放数据对象（元素），算法用于操作容器中的数据对象。</p>

				<div>
					
					<pre class="mermaid">

 flowchart TB
 c[迭代器]
   one --&gt;c--&gt; 容器
  容器 --&gt;c--&gt; one
 
one[算法]
b1[容器1]
b2[容器2]
  subgraph 容器
    b1-.-  b2-.-...对象n
  end 
</pre>
				</div>
			<h2 id="什么是stl容器">什么是STL容器</h2>
<p>STL容器就是一种数据结构，如链表、栈和队列等，这些数据结构在STL中都已经实现好了，可以直接使用。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>数据结构</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{数据结构}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em"></span><span class="mord cjk_fallback" style="color:red">数据结构</span></span></span></span></span></strong></th>
<th style="text-align:center"><strong><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>说明</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{说明}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em"></span><span class="mord cjk_fallback" style="color:red">说明</span></span></span></span></span></strong></th>
<th style="text-align:center"><strong><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>实现头文件</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{实现头文件}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em"></span><span class="mord cjk_fallback" style="color:red">实现头文件</span></span></span></span></span></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>向量（vector）</strong></td>
<td style="text-align:center"><strong>连续存储元素。底层数据结构为数组，支持快速随机访问</strong></td>
<td style="text-align:center"><strong>&lt;vector&gt;</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>字符串（string）</strong></td>
<td style="text-align:center"><strong>字符串处理容器</strong></td>
<td style="text-align:center"><strong>&lt;string&gt;</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>双端队列（deque）</strong></td>
<td style="text-align:center"><strong>连续存储的指向不同元素的指针所组成的数组。底层数据结构为一个中央控制器和多个缓冲区，支持首尾元素（中间不能）快速增删，也支持随机访问</strong></td>
<td style="text-align:center"><strong>&lt;deque&gt;</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>链表（list）</strong></td>
<td style="text-align:center"><strong>由结点组成的链表，每个结点包含着一个元素。底层数据结构为双向链表，支持结点的快速增删</strong></td>
<td style="text-align:center"><strong>&lt;list&gt;</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>栈（stack）</strong></td>
<td style="text-align:center"><strong>后进先出的序列。底层一般用deque（默认）或者list实现</strong></td>
<td style="text-align:center"><strong>&lt;stack&gt;</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>队列（queue）</strong></td>
<td style="text-align:center"><strong>先进先出的序列。底层一般用deque（默认）或者list实现</strong></td>
<td style="text-align:center"><strong>&lt;queue&gt;</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>优先队列（priority_queue）</strong></td>
<td style="text-align:center"><strong>元素的进出队顺序由某个谓词或者关系函数决定的一种队列。底层数据结构一般为vector（默认）或者deque</strong></td>
<td style="text-align:center"><strong>&lt;queue&gt;</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>集合（set）/多重集合（multiset）</strong></td>
<td style="text-align:center"><strong>由结点组成的红黑树，每个结点都包含着一个元素，set中所有元素有序但不重复，multiset中所有关键字有序但不重复</strong></td>
<td style="text-align:center"><strong>&lt;set&gt;</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>映射（map）/多重映射（multimap）</strong></td>
<td style="text-align:center"><strong>由（关键字，值）对组成的集合，底层数据结构为红黑树，map中所有关键字有序但不重复，multimap中所有关键字有序但可以重复</strong></td>
<td style="text-align:center"><strong>&lt;map&gt;</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>红黑树：自平衡二叉查找树，在O(log n)时间内做查找，插入和删除。</li>
<li>为此，使用STL时必须将下面的语句插入到源代码文件开头：
<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi>u</mi><mi>s</mi><mi>i</mi><mi>n</mi><mi>g</mi><mspace width="1em"></mspace><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mi>s</mi><mi>p</mi><mi>a</mi><mi>c</mi><mi>e</mi><mspace width="1em"></mspace><mi>s</mi><mi>t</mi><mi>d</mi><mo separator="true">;</mo></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{using \quad namespace \quad std;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em"></span><span class="mord mathnormal" style="color:red">u</span><span class="mord mathnormal" style="color:red">s</span><span class="mord mathnormal" style="color:red">in</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red">g</span><span class="mspace" style="color:red;margin-right:1em"></span><span class="mord mathnormal" style="color:red">nam</span><span class="mord mathnormal" style="color:red">es</span><span class="mord mathnormal" style="color:red">p</span><span class="mord mathnormal" style="color:red">a</span><span class="mord mathnormal" style="color:red">ce</span><span class="mspace" style="color:red;margin-right:1em"></span><span class="mord mathnormal" style="color:red">s</span><span class="mord mathnormal" style="color:red">t</span><span class="mord mathnormal" style="color:red">d</span><span class="mpunct" style="color:red">;</span></span></span></span></span>
这样直接把程序代码定位到std命名空间中。</li>
</ul>
<h2 id="什么是stl算法">什么是STL算法</h2>
<ul>
<li>
<p>STL算法是用来操作容器中数据的模板函数，STL提供了大约100个实现算法的模版函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象。</p>
</li>
<li>
<p>STL算法部分主要由头文件<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mo>&lt;</mo><mi>a</mi><mi>l</mi><mi>g</mi><mi>o</mi><mi>r</mi><mi>i</mi><mi>t</mi><mi>h</mi><mi>m</mi><mo>&gt;</mo></mstyle><mtext>、</mtext><mstyle mathcolor="red"><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>c</mi><mo>&gt;</mo></mstyle><mtext>和</mtext><mstyle mathcolor="red"><mo>&lt;</mo><mi>f</mi><mi>u</mi><mi>n</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>a</mi><mi>l</mi><mo>&gt;</mo></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{&lt;algorithm&gt;}、\textcolor{red}{&lt;numeric&gt;}和\textcolor{red}{&lt;functional&gt;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mrel" style="color:red">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em"></span><span class="mord mathnormal" style="color:red">a</span><span class="mord mathnormal" style="margin-right:0.01968em;color:red">l</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red">g</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red">or</span><span class="mord mathnormal" style="color:red">i</span><span class="mord mathnormal" style="color:red">t</span><span class="mord mathnormal" style="color:red">hm</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel" style="color:red">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em"></span><span class="mord cjk_fallback">、</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel" style="color:red">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em"></span><span class="mord mathnormal" style="color:red">n</span><span class="mord mathnormal" style="color:red">u</span><span class="mord mathnormal" style="color:red">m</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red">er</span><span class="mord mathnormal" style="color:red">i</span><span class="mord mathnormal" style="color:red">c</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel" style="color:red">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em"></span><span class="mord cjk_fallback">和</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel" style="color:red">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em"></span><span class="mord mathnormal" style="margin-right:0.10764em;color:red">f</span><span class="mord mathnormal" style="color:red">u</span><span class="mord mathnormal" style="color:red">n</span><span class="mord mathnormal" style="color:red">c</span><span class="mord mathnormal" style="color:red">t</span><span class="mord mathnormal" style="color:red">i</span><span class="mord mathnormal" style="color:red">o</span><span class="mord mathnormal" style="color:red">na</span><span class="mord mathnormal" style="margin-right:0.01968em;color:red">l</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel" style="color:red">&gt;</span></span></span></span></span>组成。</p>
</li>
</ul>
<h3 id="例如以下程序使用stl算法sort实现整型数组a的递增排序">例如，以下程序使用STL算法sort()实现整型数组a的递增排序：</h3>
<div><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; 
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  
</span>{  <span class="hljs-type">int</span> a[]={<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>};
   <span class="hljs-built_in">sort</span>(a,a+<span class="hljs-number">5</span>);
   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,a[i]);	<span class="hljs-comment">//输出: 1 2 3 4 5</span>
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}<span class="hljs-comment">//本例题见程序P17-sort</span></code></pre></div>
<h2 id="什么是stl迭代器">什么是STL迭代器</h2>
<ul>
<li>STL迭代器用于访问容器中的数据对象。</li>
<li>每个容器都有自己的迭代器，只有容器自己才知道如何访问自己的元素。</li>
<li>迭代器像C/C++中的指针，算法通过迭代器来定位和操作容器中的元素。</li>
</ul>
<h3 id="常见的迭代器">常见的迭代器</h3>
<ul>
<li>iterator：指向容器中存放元素的迭代器，用于正向遍历容器中的元素。</li>
<li>const_iterator：指向容器中存放元素的常量迭代器，只能读取容器中的元素。</li>
<li>reverse_iterator：指向容器中存放元素的反向迭代器，用于反向遍历容器中的元素。</li>
<li>const_reverse_iterator：指向容器中存放元素的常量反向迭代器，只能读取容器中的元素。</li>
</ul>
<h3 id="常见的迭代器运算">常见的迭代器运算</h3>
<ul>
<li>
<p>++：正向移动迭代器。</p>
</li>
<li>
<p>–：反向移动迭代器。</p>
</li>
<li>
<p>*：返回迭代器所指的元素值。</p>
<div><pre class="hljs"><code>vector&lt;<span class="hljs-type">int</span>&gt; myv;
myv.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);
myv.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);
myv.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);
vector&lt;<span class="hljs-type">int</span>&gt;::iterator it;	<span class="hljs-comment">//定义正向迭代器it</span>
<span class="hljs-keyword">for</span> (it=myv.<span class="hljs-built_in">begin</span>();it!=myv.<span class="hljs-built_in">end</span>();++it)
                <span class="hljs-comment">//从头到尾遍历所有元素</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,*it);	<span class="hljs-comment">//输出：1 2 3</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
vector&lt;<span class="hljs-type">int</span>&gt;::reverse_iterator rit;
                <span class="hljs-comment">//定义反向迭代器rit</span>
<span class="hljs-keyword">for</span> (rit=myv.<span class="hljs-built_in">rbegin</span>();rit!=myv.<span class="hljs-built_in">rend</span>();++rit)	
                <span class="hljs-comment">//从尾到头遍历所有元素</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,*rit);	<span class="hljs-comment">//输出：3 2 1</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
<span class="hljs-comment">//本例题见程序P17-迭代器</span></code></pre></div>
<img src="https://haues-my.sharepoint.com/:i:/g/personal/sun_haues_onmicrosoft_com/Ef8umFoxCHxDgJt4Hdj9q3wBXJUNhToYAfv16iLMoFcYHA?e=Y6FM5f&amp;download=1" alt="前闭后开区间" style="zoom:80%" class="jop-noMdConv" />
</li>
</ul>
<h3 id="常见的stl容器">常见的STL容器</h3>
<ul>
<li>顺序容器</li>
<li>适配容器</li>
<li>关联容器</li>
</ul>
<h4 id="顺序容器">顺序容器</h4>
<h5 id="vector向量容器"><font color="#f23321" class="jop-noMdConv">vector（向量容器）</font></h5>
<p>它是一个向量类模板。向量容器相当于数组。</p>
<p>用于存储具有相同数据类型的一组元素，可以从末尾快速的插入与删除元素，快速地随机访问元素，但是在序列中间插入、删除元素较慢，因为需要移动插入或删除处后面的所有元素。</p>
<ul>
<li>
<p>定义vector容器的几种方式如下</p>
<div><pre class="hljs"><code>vector&lt;<span class="hljs-type">int</span>&gt; v1;		<span class="hljs-comment">//定义元素为int的向量v1</span>
<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;		<span class="hljs-comment">//指定向量v2的初始大小为10个int元素</span>
<span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">v3</span><span class="hljs-params">(<span class="hljs-number">10</span>，<span class="hljs-number">1.23</span>)</span></span>;	<span class="hljs-comment">//指定v3的10个初始元素的初值为1.23</span>
<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v4</span><span class="hljs-params">(a，a+<span class="hljs-number">5</span>)</span></span>;	<span class="hljs-comment">//用数组a[0..4]共5个元素初始化v4</span></code></pre></div>
</li>
<li>
<p>vector提供了一系列的成员函数，vector主要的成员函数如下：</p>
<div><pre class="hljs"><code><span class="hljs-built_in">empty</span>()：判断当前向量容器是否为空。
<span class="hljs-built_in">size</span>()：返回当前向量容器的中的实际元素个数。
[]：返回指定下标的元素。
<span class="hljs-built_in">reserve</span>(n)：为当前向量容器预分配n个元素的存储空间。
<span class="hljs-built_in">capacity</span>()：返回当前向量容器在重新进行内存分配以前所能容纳的元素个数。
<span class="hljs-built_in">resize</span>(n) ：调整当前向量容器的大小，使其能容纳n个元素。
<span class="hljs-built_in">push_back</span>()：在当前向量容器尾部添加了一个元素。
<span class="hljs-built_in">insert</span>(pos，elem)：在pos位置插入元素elem，即将元素elem插入到迭代器pos指定元素之前。
<span class="hljs-built_in">front</span>()：获取当前向量容器的第一个元素。
<span class="hljs-built_in">back</span>()：获取当前向量容器的最后一个元素。
<span class="hljs-built_in">erase</span>()：删除当前向量容器中某个迭代器或者迭代器区间指定的元素。
<span class="hljs-built_in">clear</span>()：删除当前向量容器中所有元素。
迭代器函数：<span class="hljs-built_in">begin</span>()、<span class="hljs-built_in">end</span>()、<span class="hljs-built_in">rbegin</span>()、<span class="hljs-built_in">rend</span>()。
</code></pre></div>
</li>
<li>
<p>示例</p>
<div><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{   vector&lt;<span class="hljs-type">int</span>&gt; myv;		<span class="hljs-comment">//定义vector容器myv</span>
    vector&lt;<span class="hljs-type">int</span>&gt;::iterator it;	<span class="hljs-comment">//定义myv的正向迭代器it</span>
    myv.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);		<span class="hljs-comment">//在myv末尾添加元素1</span>
    it=myv.<span class="hljs-built_in">begin</span>();		<span class="hljs-comment">//it迭代器指向开头元素1</span>
    myv.<span class="hljs-built_in">insert</span>(it,<span class="hljs-number">2</span>);		<span class="hljs-comment">//在it指向的元素之前插入元素2</span>
    myv.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);		<span class="hljs-comment">//在myv末尾添加元素3</span>
    myv.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);		<span class="hljs-comment">//在myv末尾添加元素4</span>
    it=myv.<span class="hljs-built_in">end</span>();		<span class="hljs-comment">//it迭代器指向尾元素4的后面</span>
    it--;			<span class="hljs-comment">//it迭代器指向尾元素4</span>
    myv.<span class="hljs-built_in">erase</span>(it);		<span class="hljs-comment">//删除元素4</span>
    <span class="hljs-keyword">for</span> (it=myv.<span class="hljs-built_in">begin</span>();it!=myv.<span class="hljs-built_in">end</span>();++it)
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,*it);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
} <span class="hljs-comment">//本例题见程序P19-vector</span></code></pre></div>
</li>
</ul>
<h5 id="string字符串容器"><font color="#f23321" class="jop-noMdConv">string（字符串容器）</font></h5>
<p>string是一个保存字符序列的容器，所有元素为字符类型，类似vector&lt;char&gt;。
除了有字符串的一些常用操作以外，还有包含了所有的序列容器的操作。字符串的常用操作包括增加、删除、修改、查找比较、连接、输入、输出等。</p>
<ul>
<li>
<p>创建string容器的几种方式如下</p>
<div><pre class="hljs"><code><span class="hljs-built_in">char</span> cstr[]=<span class="hljs-string">"China! Greate Wall"</span>;	<span class="hljs-comment">//C-字符串</span>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s1</span>(<span class="hljs-params">cstr</span>)</span>;			<span class="hljs-comment">// s1:China! Greate Wall</span>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s2</span>(<span class="hljs-params">s1</span>)</span>;				<span class="hljs-comment">// s2:China! Greate Wall</span>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s3</span>(<span class="hljs-params">cstr，<span class="hljs-number">7</span>，<span class="hljs-number">11</span></span>)</span>;		<span class="hljs-comment">// s3:Greate Wall</span>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s4</span>(<span class="hljs-params">cstr，<span class="hljs-number">6</span></span>)</span>;			<span class="hljs-comment">// s4:China!</span>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s5</span>(<span class="hljs-params"><span class="hljs-number">5</span>，<span class="hljs-string">'A'</span></span>)</span>;			<span class="hljs-comment">// s5:AAAAA</span></code></pre></div>
</li>
<li>
<p>常用的成员函数如下</p>
<div><pre class="hljs"><code><span class="hljs-built_in">empty</span>()：判断当前字符串是否为空串。
<span class="hljs-built_in">size</span>()：返回当前字符串的实际字符个数（返回结果为size_type类型）。
<span class="hljs-built_in">length</span>()：返回当前字符串的实际字符个数。
[idx]：返回当前字符串位于idx位置的字符，idx从<span class="hljs-number">0</span>开始。
<span class="hljs-built_in">at</span>(idx)：返回当前字符串位于idx位置的字符。
<span class="hljs-built_in">compare</span>(<span class="hljs-keyword">const</span> string&amp; str)：返回当前字符串与字符串str的比较结果。在比较时，若两者相等，返回<span class="hljs-number">0</span>；前者小于后者，返回<span class="hljs-number">-1</span>；否则返回<span class="hljs-number">1</span>。
<span class="hljs-built_in">append</span>(cstr)：在当前字符串的末尾添加一个字符串str。
<span class="hljs-built_in">insert</span>(size_type idx，<span class="hljs-keyword">const</span> string&amp; str)	：在当前字符串的idx处插入一个字符串str。
迭代器函数：<span class="hljs-built_in">begin</span>()、<span class="hljs-built_in">end</span>()、<span class="hljs-built_in">rbegin</span>()、<span class="hljs-built_in">rend</span>()。</code></pre></div>
</li>
<li>
<p>示例</p>
<div><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span> </span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> 
</span>{   string s1=<span class="hljs-string">""</span>,s2,s3=<span class="hljs-string">"Bye"</span>;
    s1.<span class="hljs-built_in">append</span>(<span class="hljs-string">"Good morning"</span>);	<span class="hljs-comment">//s1="Good morning"</span>
    s2=s1;				<span class="hljs-comment">//s2="Good morning"</span>
    <span class="hljs-type">int</span> i=s2.<span class="hljs-built_in">find</span>(<span class="hljs-string">"morning"</span>);		<span class="hljs-comment">//i=5</span>
    s2.<span class="hljs-built_in">replace</span>(i,s2.<span class="hljs-built_in">length</span>()-i,s3);	<span class="hljs-comment">//相当于s2.replace(5,7,s3)</span>
    cout &lt;&lt; <span class="hljs-string">"s1: "</span> &lt;&lt; s1 &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">"s2: "</span> &lt;&lt; s2 &lt;&lt; endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
} <span class="hljs-comment">//本例题见程序P21-string</span></code></pre></div>
</li>
</ul>
<h5 id="deque双端队列容器"><font color="#f23321" class="jop-noMdConv">deque（双端队列容器）</font></h5>
<p>它是一个双端队列类模板。双端队列容器由若干个块构成，每个块中元素地址是连续的，块之间的地址是不连续的，有一个特定的机制将这些块构成一个整体。可以从前面或后面快速插入与删除元素，并可以快速地随机访问元素，但删除元素较慢</p>
<p><img src="https://haues-my.sharepoint.com/:i:/g/personal/sun_haues_onmicrosoft_com/ESFaA21MwoJPuPlJZci5V2YBTKUpvw6inPwuxV7S4imNUw?e=LBfGGs&amp;download=1" alt="双端队列容器" /></p>
<ul>
<li>
<p>定义deque双端队列容器的几种方式如下：</p>
<div><pre class="hljs"><code>deque&lt;<span class="hljs-type">int</span>&gt; dq1;	<span class="hljs-comment">//定义元素为int的双端队列dq1</span>
<span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dq2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;	<span class="hljs-comment">//指定dq2的初始大小为10个int元素</span>
<span class="hljs-function">deque&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">dq3</span><span class="hljs-params">(<span class="hljs-number">10</span>，<span class="hljs-number">1.23</span>)</span></span>;
            <span class="hljs-comment">//指定dq3的10个初始元素的初值为1.23</span>
<span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dq4</span><span class="hljs-params">(dq2.begin()，dq2.end())</span></span>;	
            <span class="hljs-comment">//用dq2的所有元素初始化dq4</span>
</code></pre></div>
</li>
<li>
<p>deque的主要成员函数如下：</p>
<div><pre class="hljs"><code><span class="hljs-built_in">empty</span>()：判断双端队列容器是否为空队。
<span class="hljs-built_in">size</span>()：返回双端队列容器中元素个数。
<span class="hljs-built_in">push_front</span>(elem)：在队头插入元素elem。
<span class="hljs-built_in">push_back</span>(elem)：在队尾插入元素elem。
<span class="hljs-built_in">pop_front</span>()：删除队头一个元素。
<span class="hljs-built_in">pop_back</span>()：删除队尾一个元素。
<span class="hljs-built_in">erase</span>()：从双端队列容器中删除一个或几个元素。
<span class="hljs-built_in">clear</span>()：删除双端队列容器中所有元素。
迭代器函数：<span class="hljs-built_in">begin</span>()、<span class="hljs-built_in">end</span>()、<span class="hljs-built_in">rbegin</span>()、<span class="hljs-built_in">rend</span>()。</code></pre></div>
</li>
<li>
<p>示例</p>
<div><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disp</span><span class="hljs-params">(deque&lt;<span class="hljs-type">int</span>&gt; &amp;dq)</span>		<span class="hljs-comment">//输出dq的所有元素</span>
</span>{  deque&lt;<span class="hljs-type">int</span>&gt;::iterator iter;		<span class="hljs-comment">//定义迭代器iter</span>
   <span class="hljs-keyword">for</span> (iter=dq.<span class="hljs-built_in">begin</span>();iter!=dq.<span class="hljs-built_in">end</span>();iter++)
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,*iter);
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{  deque&lt;<span class="hljs-type">int</span>&gt; dq;			<span class="hljs-comment">//建立一个双端队列dq</span>
   dq.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">1</span>);			<span class="hljs-comment">//队头插入1</span>
   dq.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);			<span class="hljs-comment">//队尾插入2</span>
   dq.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">3</span>);			<span class="hljs-comment">//队头插入3</span>
   dq.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);			<span class="hljs-comment">//队尾插入4</span>
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dq: "</span>); <span class="hljs-built_in">disp</span>(dq);
   dq.<span class="hljs-built_in">pop_front</span>();			<span class="hljs-comment">//删除队头元素</span>
   dq.<span class="hljs-built_in">pop_back</span>();			<span class="hljs-comment">//删除队尾元素</span>
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dq: "</span>); <span class="hljs-built_in">disp</span>(dq);
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
} <span class="hljs-comment">//本例题见程序P22-deque</span></code></pre></div>
<h5 id="list链表容器">list（链表容器）</h5>
<p>它是一个双链表类模板。可以从任何地方快速插入与删除。它的每个结点之间通过指针链接，不能随机访问元素。<img src="https://haues-my.sharepoint.com/:i:/g/personal/sun_haues_onmicrosoft_com/EamFFfpb8w1DvEdKZNzjytAB-0RecSBzP8SMEBQZ2PCl1w?e=nKFJK6&amp;download=1" alt="list链表容器" /></p>
<ul>
<li>
<p>定义list容器的几种方式如下</p>
<div><pre class="hljs"><code>list&lt;<span class="hljs-type">int</span>&gt; l1;			<span class="hljs-comment">//定义元素为int的链表l1</span>
<span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l2</span> <span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;		<span class="hljs-comment">//指定链表l2的初始大小为10个int元素</span>
<span class="hljs-function">list&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">l3</span> <span class="hljs-params">(<span class="hljs-number">10</span>，<span class="hljs-number">1.23</span>)</span></span>;	<span class="hljs-comment">//指定l3的10个初始元素的初值为1.23</span>
<span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l4</span><span class="hljs-params">(a，a+<span class="hljs-number">5</span>)</span></span>;		<span class="hljs-comment">//用数组a[0..4]共5个元素初始化l4</span></code></pre></div>
</li>
<li>
<p>list主要成员函数如下</p>
<div><pre class="hljs"><code><span class="hljs-built_in">empty</span>()：判断链表容器是否为空。
<span class="hljs-built_in">size</span>()：返回链表容器中实际元素个数。
<span class="hljs-built_in">push_back</span>()：在链表尾部插入元素。
<span class="hljs-built_in">pop_back</span>()：删除链表容器的最后一个元素。
<span class="hljs-built_in">remove</span> ()：删除链表容器中所有指定值的元素。
<span class="hljs-built_in">remove_if</span>(cmp)：删除链表容器中满足条件的元素。
<span class="hljs-built_in">erase</span>()：从链表容器中删除一个或几个元素。
<span class="hljs-built_in">unique</span>()：删除链表容器中相邻的重复元素。
<span class="hljs-built_in">clear</span>()：删除链表容器中所有的元素。
<span class="hljs-built_in">insert</span>(pos，elem)：在pos位置插入元素elem，即将元素elem插入到迭代器pos指定元素之前。
<span class="hljs-built_in">insert</span>(pos，n，elem)：在pos位置插入n个元素elem。
<span class="hljs-built_in">insert</span>(pos，pos1，pos2)：在迭代器pos处插入[pos1，pos2)的元素。
<span class="hljs-built_in">reverse</span>()：反转链表。
<span class="hljs-built_in">sort</span>()：对链表容器中的元素排序。
迭代器函数：<span class="hljs-built_in">begin</span>()、<span class="hljs-built_in">end</span>()、<span class="hljs-built_in">rbegin</span>()、<span class="hljs-built_in">rend</span>()。</code></pre></div>
<p><font color="#f23321" class="jop-noMdConv">说明：</font>STL提供的sort()排序算法主要用于<font color="#f23321" class="jop-noMdConv">支持随机访问</font>的容器，而list容器不支持随机访问，为此，list容器提供了sort()成员函数用于元素排序。类似的还有unique()、reverse()、merge()等STL算法。</p>
</li>
<li>
<p>示例</p>
<div><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disp</span><span class="hljs-params">(list&lt;<span class="hljs-type">int</span>&gt; &amp;lst)</span>		<span class="hljs-comment">//输出lst的所有元素</span>
</span>{  list&lt;<span class="hljs-type">int</span>&gt;::iterator it;
   <span class="hljs-keyword">for</span> (it=lst.<span class="hljs-built_in">begin</span>();it!=lst.<span class="hljs-built_in">end</span>();it++)
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,*it);
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{  list&lt;<span class="hljs-type">int</span>&gt; lst;			<span class="hljs-comment">//定义list容器lst</span>
   list&lt;<span class="hljs-type">int</span>&gt;::iterator it,start,end;
   lst.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>);			<span class="hljs-comment">//添加5个整数5,2,4,1,3</span>
   lst.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);  lst.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);
   lst.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);  lst.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"初始lst: "</span>); <span class="hljs-built_in">disp</span>(lst);
   it=lst.<span class="hljs-built_in">begin</span>();			<span class="hljs-comment">//it指向首元素5</span>
   start=++lst.<span class="hljs-built_in">begin</span>();		<span class="hljs-comment">//start指向第2个元素2</span>
   end=--lst.<span class="hljs-built_in">end</span>();			<span class="hljs-comment">//end指向尾元素3</span>
   lst.<span class="hljs-built_in">insert</span>(it,start,end);
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"执行lst.insert(it,start,end)\n"</span>);
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"插入后lst: "</span>); <span class="hljs-built_in">disp</span>(lst);
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
} <span class="hljs-comment">//本例题见程序P24-list</span>
</code></pre></div>
</li>
</ul>
</li>
</ul>
<h4 id="关联容器">关联容器</h4>
<h5 id="set集合容器-multiset多重集容器">set（集合容器）/ multiset（多重集容器）</h5>
<p>set和multiset都是集合类模板，其元素值称为关键字。set中元素的关键字是唯一的，multiset中元素的关键字可以不唯一，而且默认情况下会对元素按关键字自动进行升序排列。</p>
<p>查找速度比较快，同时支持集合的交、差和并等一些集合上的运算，如果需要集合中的元素允许重复那么可以使用multiset。</p>
<ul>
<li>
<p>set/multiset的成员函数如下：</p>
<div><pre class="hljs"><code><span class="hljs-built_in">empty</span>()：判断容器是否为空。
<span class="hljs-built_in">size</span>()：返回容器中实际元素个数。
<span class="hljs-built_in">insert</span>()：插入元素。
<span class="hljs-built_in">erase</span>()：从容器删除一个或几个元素。
<span class="hljs-built_in">clear</span>()：删除所有元素。
<span class="hljs-built_in">count</span>(k)：返回容器中关键字k出现的次数。
<span class="hljs-built_in">find</span>(k)：如果容器中存在关键字为k的元素，返回该元素的迭代器，否则返回<span class="hljs-built_in">end</span>()值。
<span class="hljs-built_in">upper_bound</span>()：返回一个迭代器，指向关键字大于k的第一个元素。
<span class="hljs-built_in">lower_bound</span>()：返回一个迭代器，指向关键字不小于k的第一个元素。
迭代器函数：<span class="hljs-built_in">begin</span>()、<span class="hljs-built_in">end</span>()、<span class="hljs-built_in">rbegin</span>()、<span class="hljs-built_in">rend</span>()。</code></pre></div>
</li>
<li>
<p>示例</p>
<div><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{  set&lt;<span class="hljs-type">int</span>&gt; s;			<span class="hljs-comment">//定义set容器s</span>
   set&lt;<span class="hljs-type">int</span>&gt;::iterator it;	<span class="hljs-comment">//定义set容器迭代器it</span>
   s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>);
   s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);
   s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);
   s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>);
   s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">" s: "</span>);
   <span class="hljs-keyword">for</span> (it=s.<span class="hljs-built_in">begin</span>();it!=s.<span class="hljs-built_in">end</span>();it++)
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,*it);
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
 
 <span class="hljs-comment">//s:1 2 3 4</span>
 
   multiset&lt;<span class="hljs-type">int</span>&gt; ms;	<span class="hljs-comment">//定义multiset容器ms</span>
   multiset&lt;<span class="hljs-type">int</span>&gt;::iterator mit;
            <span class="hljs-comment">//定义multiset容器迭代器mit</span>
   ms.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>);
   ms.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);
   ms.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);
   ms.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>);
   ms.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"ms: "</span>);
   <span class="hljs-keyword">for</span> (mit=ms.<span class="hljs-built_in">begin</span>();mit!=ms.<span class="hljs-built_in">end</span>();mit++)
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,*mit);
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}<span class="hljs-comment">//本例题见程序P25-set/multiset</span>

<span class="hljs-comment">//ms:1 2 3 4</span>
</code></pre></div>
</li>
</ul>
<h5 id="map映射容器-multimap多重映射容器">map（映射容器）/ multimap（多重映射容器）</h5>
<p>​    map和multimap都是映射类模板。映射是实现关键字与值关系的存储结构，可以使用一个关键字key来访问相应的数据值value。
​    在set/multiset中的key和value都是key类型，而key和value是一个pair类结构。
​    pair类结构的声明形如：</p>
<div><pre class="hljs"><code><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair</span>
{   T first;
    T second;
}</code></pre></div>
<p>​    map/multimap利用pair的&lt;运算符将所有元素按key的升序排列，以红黑树的形式存储，可以根据key快速地找到对应的value（查找时间为O(log2n)）。
​    map中不允许关键字重复出现，支持[]运算符；而multimap中允许关键字重复出现，但不支持[]运算符。</p>
<ul>
<li>
<p>map/multimap的主要成员函数如下：</p>
<div><pre class="hljs"><code><span class="hljs-built_in">empty</span>()：判断容器是否为空。
<span class="hljs-built_in">size</span>()：返回容器中实际元素个数。
map[key]：返回关键字为key的元素的引用，如果不存在这样的关键字，则以key作为关键字插入一个元素（不适合multimap）。
<span class="hljs-built_in">insert</span>(elem)：插入一个元素elem并返回该元素的位置。
<span class="hljs-built_in">clear</span>()：删除所有元素。
<span class="hljs-built_in">find</span>()：在容器中查找元素。
<span class="hljs-built_in">count</span>()：容器中指定关键字的元素个数（map中只有<span class="hljs-number">1</span>或者<span class="hljs-number">0</span>）。
迭代器函数：<span class="hljs-built_in">begin</span>()、<span class="hljs-built_in">end</span>()、<span class="hljs-built_in">rbegin</span>()、<span class="hljs-built_in">rend</span>()。</code></pre></div>
<ul>
<li>在map中修改元素非常简单，这是因为map容器已经对[]运算符进行了重载。例如：</li>
</ul>
<div><pre class="hljs"><code>map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; mymap;	
           <span class="hljs-comment">//定义map容器mymap，其元素类型为pair&lt;char,int&gt;</span>
mymap[<span class="hljs-string">'a'</span>] = <span class="hljs-number">1</span>;   <span class="hljs-comment">//或者mymap.insert(pair&lt;char，int&gt;('a',1) );</span>
</code></pre></div>
<ul>
<li>获得map中一个值的最简单方法如下：
int ans = mymap[‘a’];
只有当map中有这个关键字（‘a’）时才会成功，否则会自动插入一个元素，值为初始化值。可以使用find() 方法来发现一个关键字是否存在。</li>
</ul>
</li>
<li>
<p>示例</p>
<div><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{   map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; mymap;	<span class="hljs-comment">//定义map容器mymap</span>
    mymap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt;(<span class="hljs-string">'a'</span>,<span class="hljs-number">1</span>));
                <span class="hljs-comment">//插入方式1</span>
    mymap.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-string">'b'</span>,<span class="hljs-number">2</span>));
                <span class="hljs-comment">//插入方式2</span>
    mymap[<span class="hljs-string">'c'</span>]=<span class="hljs-number">3</span>;										<span class="hljs-comment">//插入方式3</span>
    map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt;::iterator it;
    <span class="hljs-keyword">for</span>(it=mymap.<span class="hljs-built_in">begin</span>();it!=mymap.<span class="hljs-built_in">end</span>();it++)
    	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"[%c,%d] "</span>,it-&gt;first,it-&gt;second);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
} <span class="hljs-comment">//本例题见程序P28-map</span>

[a,<span class="hljs-number">1</span>] [b,<span class="hljs-number">2</span>] [c,<span class="hljs-number">3</span>]
</code></pre></div>
</li>
</ul>
<h4 id="适配器容器">适配器容器</h4>
<h5 id="stack栈容器">stack（栈容器）</h5>
<p>它是一个栈类模板，和数据结构中的栈一样，具有后进先出的特点。栈容器默认的底层容器是deque。也可以指定其他底层容器。
例如，以下语句指定myst栈的底层容器为vector：</p>
<div><pre class="hljs"><code>stack&lt;string,vector&lt;string&gt; &gt; myst;	
                <span class="hljs-comment">//第2个参数指定底层容器为vector</span>
</code></pre></div>
<ul>
<li>
<p>stack主要的成员函数如下</p>
<div><pre class="hljs"><code><span class="hljs-built_in">empty</span>()：判断栈容器是否为空。
<span class="hljs-built_in">size</span>()：返回栈容器中实际元素个数。
<span class="hljs-built_in">push</span>(elem)：元素elem进栈。
<span class="hljs-built_in">top</span>()：返回栈顶元素。
<span class="hljs-built_in">pop</span>()：元素出栈。</code></pre></div>
<p><font color="#f23321" class="jop-noMdConv">注意：</font>stack容器没有begin()/end()和rbegin()/rend()这样的用于迭代器的成员函数。</p>
</li>
<li>
<p>示例</p>
<div><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{  stack&lt;<span class="hljs-type">int</span>&gt; st;
   st.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>); st.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>); st.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"栈顶元素: %d\n"</span>,st.<span class="hljs-built_in">top</span>());
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"出栈顺序: "</span>);
   <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) 	<span class="hljs-comment">//栈不空时出栈所有元素</span>
   {<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,st.<span class="hljs-built_in">top</span>());
    st.<span class="hljs-built_in">pop</span>() ;
   }
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
} <span class="hljs-comment">//本例题见程序P28-stack</span>
</code></pre></div>
</li>
</ul>
<h5 id="queue队列容器">queue（队列容器）</h5>
<p>​    它是一个队列类模板，和数据结构中的队列一样，具有先进先出的特点。不允许顺序遍历，没有begin()/end()和rbegin()/rend()这样的用于迭代器的成员函数。</p>
<ul>
<li>
<p>队列容器的主要成员函数如下</p>
<div><pre class="hljs"><code><span class="hljs-built_in">empty</span>()：判断队列容器是否为空。
<span class="hljs-built_in">size</span>()：返回队列容器中实际元素个数。
<span class="hljs-built_in">front</span>()：返回队头元素。
<span class="hljs-built_in">back</span>()：返回队尾元素。
<span class="hljs-built_in">push</span>(elem)：元素elem进队。
<span class="hljs-built_in">pop</span>()：元素出队。</code></pre></div>
</li>
<li>
<p>示例</p>
<div><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{  queue&lt;<span class="hljs-type">int</span>&gt; qu;
   qu.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>); qu.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>); qu.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"队头元素: %d\n"</span>,qu.<span class="hljs-built_in">front</span>());
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"队尾元素: %d\n"</span>,qu.<span class="hljs-built_in">back</span>());
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"出队顺序: "</span>);
   <span class="hljs-keyword">while</span> (!qu.<span class="hljs-built_in">empty</span>())		<span class="hljs-comment">//出队所有元素</span>
   {	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,qu.<span class="hljs-built_in">front</span>());
    qu.<span class="hljs-built_in">pop</span>();
   }
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
} <span class="hljs-comment">//本例题见程序P29-queue</span>
</code></pre></div>
</li>
</ul>
<h5 id="3priority_queue优先队列容器">3）priority_queue（优先队列容器）</h5>
<p>它是一个优先队列类模板。优先队列是一种具有受限访问操作的存储结构，元素可以以任意顺序进入优先队列。
一旦元素在优先队列容器中，出队操作将出队列最高优先级元素。</p>
<ul>
<li>
<p>主要成员函数如下</p>
<div><pre class="hljs"><code><span class="hljs-built_in">empty</span>()：判断优先队列容器是否为空。
<span class="hljs-built_in">size</span>()：返回优先队列容器中实际元素个数。
<span class="hljs-built_in">push</span>(elem)：元素elem进队。
<span class="hljs-built_in">top</span>()：获取队头元素。
<span class="hljs-built_in">pop</span>()：元素出队。
</code></pre></div>
</li>
<li>
<p>示例</p>
<div><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{   priority_queue&lt;<span class="hljs-type">int</span>&gt; qu;
    qu.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>); qu.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>); qu.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"队头元素: %d\n"</span>,qu.<span class="hljs-built_in">top</span>());
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"出队顺序: "</span>);
    <span class="hljs-keyword">while</span> (!qu.<span class="hljs-built_in">empty</span>())		<span class="hljs-comment">//出队所有元素</span>
    {	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,qu.<span class="hljs-built_in">top</span>());
    qu.<span class="hljs-built_in">pop</span>();
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
} <span class="hljs-comment">//本例题见程序P30-priority_queue</span>
</code></pre></div>
</li>
</ul>
<h1 id="stl在算法设计中的应用">STL在算法设计中的应用</h1>
<h2 id="存放主数据">存放主数据</h2>
<p>算法设计重要步骤是设计数据的存储结构，除非特别指定，程序员可以采用STL中的容器存放主数据，选择何种容器不仅要考虑数据的类型，还有考虑数据的处理过程。
例如，字符串可以采用string或者vector&lt;char&gt;来存储，链表可以采用list来存储。</p>
<ul>
<li>
<p>【例1.11】有一段英文由若干单词组成，单词之间用一个空格分隔。编写程序提取其中的所有单词。
解：这里的主数据是一段英文，采用string字符串str存储它，最后提取的单词采用vector&lt;string&gt;容器words存储。</p>
<div><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(string str,vector&lt;string&gt; &amp;words)</span> <span class="hljs-comment">//产生所有单词words</span>
</span>{  string w;<span class="hljs-comment">//字符串容器变量</span>
   <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;
   <span class="hljs-type">int</span> j=str.<span class="hljs-built_in">find</span>(<span class="hljs-string">" "</span>);	<span class="hljs-comment">//查找第一个空格 P20</span>
   <span class="hljs-keyword">while</span> (j!=<span class="hljs-number">-1</span>)		<span class="hljs-comment">//找到单词后循环</span>
   {	w=str.<span class="hljs-built_in">substr</span>(i,j-i);	<span class="hljs-comment">//提取一个单词</span>
    words.<span class="hljs-built_in">push_back</span>(w);	<span class="hljs-comment">//单词添加到words中</span>
    i=j+<span class="hljs-number">1</span>;
    j=str.<span class="hljs-built_in">find</span>(<span class="hljs-string">" "</span>,i);	<span class="hljs-comment">//查找下一个空格</span>
   }
   <span class="hljs-keyword">if</span> (i&lt;str.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>)	<span class="hljs-comment">//处理最后一个单词</span>
   {	w=str.<span class="hljs-built_in">substr</span>(i);	<span class="hljs-comment">//提取最后一个单词</span>
    words.<span class="hljs-built_in">push_back</span>(w);	<span class="hljs-comment">//最后单词添加到words中</span>
   }
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> 
</span>{  string str=<span class="hljs-string">"The following code computes the intersection of two arrays"</span>;
   vector&lt;string&gt; words;
   <span class="hljs-built_in">solve</span>(str,words);
   cout &lt;&lt; <span class="hljs-string">"所有的单词:"</span> &lt;&lt; endl;	<span class="hljs-comment">//输出结果</span>
   vector&lt;string&gt;::iterator it;
   <span class="hljs-keyword">for</span> (it=words.<span class="hljs-built_in">begin</span>();it!=words.<span class="hljs-built_in">end</span>();++it)
    cout &lt;&lt; <span class="hljs-string">"  "</span> &lt;&lt; *it &lt;&lt; endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
} <span class="hljs-comment">//本例题见程序Exam1-11</span>
</code></pre></div>
<ul>
<li>所有的单词:
The
following
code
computes
the
intersection
of
two
arrays</li>
</ul>
</li>
</ul>
<h2 id="存放临时数据">存放临时数据</h2>
<p>​    在算法设计中，有时需要存放一些临时数据。通常的情况是，如果后存入的元素先处理，可以使用stack栈容器；
​    如果先存入的元素先处理，可以使用queue队列容器；如果元素处理顺序按某个优先级进行，可以使用priority_queue优先队列容器。</p>
<ul>
<li>【例1.12】设计一个算法，判断一个含有()、[]、{}三种类型括号的表达式中所有括号是否匹配。
解：这里的主数据是一个字符串表达式，采用string字符串str存储它。在判断括号是否匹配时需要用到一个栈（因为每个右括号都是和前面最近的左括号匹配），采用stack&lt;char&gt;容器作为栈。</li>
</ul>
<div><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">solve</span><span class="hljs-params">(string str)</span>	    <span class="hljs-comment">//判断str中括号是否匹配</span>
</span>{  stack&lt;<span class="hljs-type">char</span>&gt; st;
   <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;
   <span class="hljs-keyword">while</span> (i&lt;str.<span class="hljs-built_in">length</span>())	    <span class="hljs-comment">//扫描str的所有字符</span>
   {	<span class="hljs-keyword">if</span> (str[i]==<span class="hljs-string">'('</span> || str[i]==<span class="hljs-string">'['</span> || str[i]==<span class="hljs-string">'{'</span>)
       st.<span class="hljs-built_in">push</span>(str[i]);	    <span class="hljs-comment">//所有左括号进栈</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i]==<span class="hljs-string">')'</span>)	    <span class="hljs-comment">//当前字符为')'</span>
    {   <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">'('</span>)    <span class="hljs-comment">//若栈顶不是匹配的'('，返回假</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">else</span>		    <span class="hljs-comment">//若栈顶是匹配的'('，退栈</span>
        st.<span class="hljs-built_in">pop</span>();
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i]==<span class="hljs-string">']'</span>)		<span class="hljs-comment">//当前字符为']'</span>
    {  <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">'['</span>)		<span class="hljs-comment">//若栈顶不是匹配的'['，返回假</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
       <span class="hljs-keyword">else</span>				<span class="hljs-comment">//若栈顶是匹配的'['，退栈</span>
        st.<span class="hljs-built_in">pop</span>();
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i]==<span class="hljs-string">'}'</span>)		<span class="hljs-comment">//当前字符为'}'</span>
    {   <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">'{'</span>)	<span class="hljs-comment">//若栈顶不是匹配的'{'，返回假</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">else</span>			<span class="hljs-comment">//若栈顶是匹配的'{'，退栈</span>
        st.<span class="hljs-built_in">pop</span>();
    }
    i++;
    }
    <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>())			<span class="hljs-comment">//str处理完毕并且栈空返回真</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;			<span class="hljs-comment">//否则返回假</span>
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> 
</span>{  cout &lt;&lt; <span class="hljs-string">"求解结果:"</span> &lt;&lt; endl;
   string str=<span class="hljs-string">"(a+[b-c]+d)"</span>;
   cout &lt;&lt; <span class="hljs-string">"  "</span> &lt;&lt; str &lt;&lt; 
        (<span class="hljs-built_in">solve</span>(str)?<span class="hljs-string">"中括号匹配"</span>:<span class="hljs-string">"中括号不匹配"</span>) &lt;&lt; endl;
   str=<span class="hljs-string">"(a+[b-c}+d)"</span>;
   cout &lt;&lt; <span class="hljs-string">"  "</span> &lt;&lt; str &lt;&lt; 
        (<span class="hljs-built_in">solve</span>(str)?<span class="hljs-string">"中括号匹配"</span>:<span class="hljs-string">"中括号不匹配"</span>) &lt;&lt; endl;
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
} <span class="hljs-comment">//本例题见程序Exam1-12</span>


(a+[b-c]+d) 中括号匹配
(a+[b-c}+d) 中括号不匹配

</code></pre></div>
<h2 id="检测数据元素的唯一性">检测数据元素的唯一性</h2>
<p>可以使用map容器或者哈希表容器检测数据元素是否唯一或者存放累计个数</p>
<ul>
<li>【例1.13】设计一个算法判断字符串str中每个字符是否唯一。如，"abc"的每个字符是唯一的，算法返回true，而"accb"的中字符’c’不是唯一的，算法返回false。
解：设计map&lt;char，int&gt;容器mymap，第一个分量key的类型为char，第二个分量value的类型为int，表示对应关键字出现的次数。
将字符串str中每个字符作为关键字插入到map容器中，插入后对应出现次数增1。如果某个字符的出现次数大于1，表示不唯一，返回false；如果所有字符唯一，返回true。</li>
</ul>
<h2 id="数组排序">数组排序</h2>
<p>​     对于list容器的元素排序可以使用其成员函数sort()，对于数组或者vector等具有随机访问特性的容器，可以使用STL算法sort()。
​    下面以STL算法sort()为例讨论。</p>
<h3 id="内置数据类型的排序">内置数据类型的排序</h3>
<p>对于内置数据类型的数据，sort()默认是以less&lt;T&gt;（小于关系函数）作为关系函数实现递增排序。
为了实现递减排序，需要调用&lt;functional&gt;头文件中定义的greater类模板。
例如，以下程序使用greater&lt;int&gt;()实现vector&lt;int&gt;容器元素的递减排序（其中sort(myv.begin(),myv.end(),less&lt;int&gt;())语句等同于sort(myv.begin(),myv.end())，实现默认的递增排序）：</p>
<div><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span>			<span class="hljs-comment">//包含less、greater等</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Disp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;myv)</span>		<span class="hljs-comment">//输出vector的元素</span>
</span>{  vector&lt;<span class="hljs-type">int</span>&gt;::iterator it;
   <span class="hljs-keyword">for</span>(it = myv.<span class="hljs-built_in">begin</span>();it!=myv.<span class="hljs-built_in">end</span>();it++)
    cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;
   cout &lt;&lt; endl;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{  <span class="hljs-type">int</span> a[]={<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>};
   <span class="hljs-type">int</span> n=<span class="hljs-built_in">sizeof</span>(a)/<span class="hljs-built_in">sizeof</span>(a[<span class="hljs-number">0</span>]);
   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">myv</span><span class="hljs-params">(a,a+n)</span></span>;
   cout &lt;&lt; <span class="hljs-string">"初始myv:  "</span>; <span class="hljs-built_in">Disp</span>(myv);	<span class="hljs-comment">//输出：2 1 5 4 3</span>
   <span class="hljs-built_in">sort</span>(myv.<span class="hljs-built_in">begin</span>(),myv.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">less</span>&lt;<span class="hljs-type">int</span>&gt;());
   cout &lt;&lt; <span class="hljs-string">"递增排序: "</span>; <span class="hljs-built_in">Disp</span>(myv);	<span class="hljs-comment">//输出：1 2 3 4 5</span>
   <span class="hljs-built_in">sort</span>(myv.<span class="hljs-built_in">begin</span>(),myv.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());
   cout &lt;&lt; <span class="hljs-string">"递减排序: "</span>; <span class="hljs-built_in">Disp</span>(myv);	<span class="hljs-comment">//输出：5 4 3 2 1</span>
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>
<h3 id="自定义数据类型的排序">自定义数据类型的排序</h3>
<p>对于自定义数据类型如结构体数据，同样默认是less<t class="jop-noMdConv">（即小于关系函数）作为关系函数，但需要重载该函数。另外还可以自己定义关系函数()。在这些重载函数或者关系函数中指定数据的排序顺序（按哪些结构体成员排序，是递增还是递减）。
归纳起来，实现排序时主要有两种方式：</t></p>
<ul>
<li>
<p>方式1：在声明结构体类型中重载&lt;运算符，以实现按指定成员的递增或者递减排序。如sort(myv.begin(),myv.end())调用默认&lt;运算符对myv容器的所有元素实现排序。</p>
</li>
<li>
<p>方式2：自己定义关系函数()，以实现按指定成员的递增或者递减排序。如sort(myv.begin(),myv.end(),Cmp())调用Cmp的()运算符对myv容器的所有元素实现排序。</p>
</li>
<li>
<p>示例</p>
<div><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stud</span>
{  <span class="hljs-type">int</span> no;
   string name;
   <span class="hljs-built_in">Stud</span>(<span class="hljs-type">int</span> no1,string name1)	<span class="hljs-comment">//构造函数</span>
   {	no=no1;
    name=name1;
   }
   <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Stud &amp;s) <span class="hljs-keyword">const</span>	<span class="hljs-comment">//方式1：重载&lt;运算符</span>
   {
    <span class="hljs-keyword">return</span> s.no&lt;no;   <span class="hljs-comment">//用于按no递减排序，将&lt;改为&gt;则按no递增排序</span>
   }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cmp</span>			<span class="hljs-comment">//方式2：定义关系函数()</span>
{  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Stud &amp;s,<span class="hljs-keyword">const</span> Stud &amp;t)</span> <span class="hljs-keyword">const</span>
   </span>{
    <span class="hljs-keyword">return</span> s.name&lt;t.name; 
        <span class="hljs-comment">//用于按name递增排序，将&lt;改为&gt;则按name递减排序</span>
   }
};
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Disp</span><span class="hljs-params">(vector&lt;Stud&gt; &amp;myv)</span>	<span class="hljs-comment">//输出vector的元素</span>
</span>{   vector&lt;Stud&gt;::iterator it;
    <span class="hljs-keyword">for</span>(it = myv.<span class="hljs-built_in">begin</span>();it!=myv.<span class="hljs-built_in">end</span>();it++)
    cout &lt;&lt; it-&gt;no &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; it-&gt;name &lt;&lt; <span class="hljs-string">"\t"</span>;
    cout &lt;&lt; endl;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{  Stud a[]={<span class="hljs-built_in">Stud</span>(<span class="hljs-number">2</span>,<span class="hljs-string">"Mary"</span>),<span class="hljs-built_in">Stud</span>(<span class="hljs-number">1</span>,<span class="hljs-string">"John"</span>),<span class="hljs-built_in">Stud</span>(<span class="hljs-number">5</span>,<span class="hljs-string">"Smith"</span>)};
   <span class="hljs-type">int</span> n=<span class="hljs-built_in">sizeof</span>(a)/<span class="hljs-built_in">sizeof</span>(a[<span class="hljs-number">0</span>]);
   <span class="hljs-function">vector&lt;Stud&gt; <span class="hljs-title">myv</span><span class="hljs-params">(a,a+n)</span></span>;
   cout &lt;&lt; <span class="hljs-string">"初始myv:    "</span>; <span class="hljs-built_in">Disp</span>(myv);  
            <span class="hljs-comment">//输出：2,Mary   1,John  5,Smith</span>
   <span class="hljs-built_in">sort</span>(myv.<span class="hljs-built_in">begin</span>(),myv.<span class="hljs-built_in">end</span>());	  <span class="hljs-comment">//默认使用&lt;运算符排序</span>
   cout &lt;&lt; <span class="hljs-string">"按no递减排序:   "</span>; <span class="hljs-built_in">Disp</span>(myv);	
            <span class="hljs-comment">//输出：5,Smith  2,Mary  1,John</span>
   <span class="hljs-built_in">sort</span>(myv.<span class="hljs-built_in">begin</span>(),myv.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">Cmp</span>());  <span class="hljs-comment">//使用Cmp中的()运算符进行排序</span>
   cout &lt;&lt; <span class="hljs-string">"按name递增排序: "</span>; <span class="hljs-built_in">Disp</span>(myv);
            <span class="hljs-comment">//输出：1,John   2,Mary  5,Smith</span>
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>
<p>在函数末尾加CONST，这样的函数叫常成员函数。常成员函数可以理解为是一个“只读”函数，它既不能更改数据成员的值，也不能调用那些能引起数据成员值变化的成员函数，只能调用const成员函数</p>
</li>
</ul>
<h2 id="优先队列作为堆">优先队列作为堆</h2>
<h3 id="元素为内置数据类型的堆">元素为内置数据类型的堆</h3>
<p>​    对于C/C++内置数据类型，默认是less&lt;T&gt;（小于关系函数）作为关系函数，值越大优先级的越高（即大根堆），可以改为以greater&lt;T&gt;作为关系函数，这样值越大优先级的越低（即小根堆）。
​    例如，以下程序中pq1为大根堆（默认），pq2为小根堆（通过greater&lt;int&gt;实现）：</p>
<ul>
<li>
<p>示例</p>
<div><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{  <span class="hljs-type">int</span> a[]={<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>};
   <span class="hljs-type">int</span> n=<span class="hljs-built_in">sizeof</span>(a)/<span class="hljs-built_in">sizeof</span>(a[<span class="hljs-number">0</span>]);
   <span class="hljs-comment">//(1)优先级队列pq1默认是使用vector作容器</span>
   <span class="hljs-function">priority_queue&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pq1</span><span class="hljs-params">(a,a+n)</span></span>;
   cout &lt;&lt; <span class="hljs-string">"pq1: "</span>;
   <span class="hljs-keyword">while</span> (!pq1.<span class="hljs-built_in">empty</span>())
   {	cout &lt;&lt; pq1.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">" "</span>;	<span class="hljs-comment">//while循环输出:6 5 4 3 2 1</span>
    pq1.<span class="hljs-built_in">pop</span>();
   }
   cout &lt;&lt; endl;
   <span class="hljs-comment">//(2)优先级队列pq2使用vector作容器,int元素的关系函数改为greater</span>
   priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">pq2</span>(a,a+n);
   cout &lt;&lt; <span class="hljs-string">"pq2: "</span>;
   <span class="hljs-keyword">while</span> (!pq2.<span class="hljs-built_in">empty</span>())
   {	cout &lt;&lt; pq2.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">" "</span>;	<span class="hljs-comment">//while循环输出:1 2 3 4 5 6</span>
    pq2.<span class="hljs-built_in">pop</span>();
   }
   cout &lt;&lt; endl;
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre></div>
</li>
</ul>
<h3 id="元素为自定义类型的堆">元素为自定义类型的堆</h3>
<p>对于自定义数据类型如结构体数据，同样默认是less&lt;T&gt;（即小于关系函数）作为关系函数，但需要重载该函数。
另外还可以自己定义关系函数()。在这些重载函数或者关系函数中指定数据的优先级（优先级取决于哪些结构体，是越大越优先还是越小越优先）。</p>
<ul>
<li>示例</li>
</ul>
<div><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stud</span>					<span class="hljs-comment">//声明结构体Stud</span>
{  <span class="hljs-type">int</span> no;
   string name;
   <span class="hljs-built_in">Stud</span>(<span class="hljs-type">int</span> n,string na)			<span class="hljs-comment">//构造函数</span>
   {	no=n;
    name=na;
   }
   <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Stud &amp;s) <span class="hljs-keyword">const</span>	<span class="hljs-comment">//重载&lt;关系函数</span>
   {	<span class="hljs-keyword">return</span> <span class="hljs-built_in">no</span>&lt;s.no;  }
   <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-keyword">const</span> Stud &amp;s) <span class="hljs-keyword">const</span>	<span class="hljs-comment">//重载&gt;关系函数</span>
   {	<span class="hljs-keyword">return</span> no&gt;s.no;  }
};
<span class="hljs-comment">//结构体的关系函数,改写operator()</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">StudCmp</span>
{   <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Stud &amp;s,<span class="hljs-keyword">const</span> Stud &amp;t)</span> <span class="hljs-keyword">const</span>
    </span>{
    <span class="hljs-keyword">return</span> s.name&lt;t.name;		<span class="hljs-comment">//name越大越优先</span>
    }
};
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{  Stud a[]={<span class="hljs-built_in">Stud</span>(<span class="hljs-number">2</span>,<span class="hljs-string">"Mary"</span>),<span class="hljs-built_in">Stud</span>(<span class="hljs-number">1</span>,<span class="hljs-string">"John"</span>),<span class="hljs-built_in">Stud</span>(<span class="hljs-number">5</span>,<span class="hljs-string">"Smith"</span>)};
   <span class="hljs-type">int</span> n=<span class="hljs-built_in">sizeof</span>(a)/<span class="hljs-built_in">sizeof</span>(a[<span class="hljs-number">0</span>]);
   <span class="hljs-comment">//(1)使用Stud结构体的&lt;关系函数定义pq1</span>
   <span class="hljs-function">priority_queue&lt;Stud&gt; <span class="hljs-title">pq1</span><span class="hljs-params">(a,a+n)</span></span>;
   cout &lt;&lt; <span class="hljs-string">"pq1出队顺序: "</span>;
   <span class="hljs-keyword">while</span> (!pq1.<span class="hljs-built_in">empty</span>())		<span class="hljs-comment">//按no递减输出</span>
   {	cout &lt;&lt; <span class="hljs-string">"["</span> &lt;&lt; pq1.<span class="hljs-built_in">top</span>().no &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; 
            pq1.<span class="hljs-built_in">top</span>().name &lt;&lt; <span class="hljs-string">"]\t"</span>;
    pq1.<span class="hljs-built_in">pop</span>();
   }
   cout &lt;&lt; endl;

 
 
 pq1出队顺序: [<span class="hljs-number">5</span>,Smith]   [<span class="hljs-number">2</span>,Mary]    [<span class="hljs-number">1</span>,John]
 
     <span class="hljs-comment">//(2)使用Stud结构体的&gt;关系函数定义pq2</span>
    priority_queue&lt;Stud,deque&lt;Stud&gt;,greater&lt;Stud&gt; &gt; <span class="hljs-built_in">pq2</span>(a,a+n);
    cout &lt;&lt; <span class="hljs-string">"pq2出队顺序: "</span>;
    <span class="hljs-keyword">while</span> (!pq2.<span class="hljs-built_in">empty</span>())			<span class="hljs-comment">//按no递增输出</span>
    {	cout &lt;&lt; <span class="hljs-string">"["</span> &lt;&lt; pq2.<span class="hljs-built_in">top</span>().no &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; 
            pq2.<span class="hljs-built_in">top</span>().name &lt;&lt; <span class="hljs-string">"]\t"</span>;
    pq2.<span class="hljs-built_in">pop</span>();
    }
    cout &lt;&lt; endl;

 
 pq2出队顺序: [<span class="hljs-number">1</span>,John]    [<span class="hljs-number">2</span>,Mary]    [<span class="hljs-number">5</span>,Smith]
 
 
     <span class="hljs-comment">//(3)使用结构体StudCmp的关系函数定义pq3</span>
   priority_queue&lt;Stud,deque&lt;Stud&gt;,StudCmp &gt; <span class="hljs-built_in">pq3</span>(a,a+n);
   cout &lt;&lt; <span class="hljs-string">"pq3出队顺序: "</span>;
   <span class="hljs-keyword">while</span> (!pq3.<span class="hljs-built_in">empty</span>())		<span class="hljs-comment">//按name递减输出</span>
   {	cout &lt;&lt; <span class="hljs-string">"["</span> &lt;&lt; pq3.<span class="hljs-built_in">top</span>().no &lt;&lt; <span class="hljs-string">","</span> 
            &lt;&lt; pq3.<span class="hljs-built_in">top</span>().name &lt;&lt; <span class="hljs-string">"]\t"</span>;
    pq3.<span class="hljs-built_in">pop</span>();
   }
   cout &lt;&lt; endl;
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}


pq3出队顺序: [<span class="hljs-number">5</span>,Smith]   [<span class="hljs-number">2</span>,Mary]    [<span class="hljs-number">1</span>,John]


</code></pre></div>
<h1 id="补充知识">补充知识</h1>
<ul>
<li>
<p>实际上，编译系统为每一个字符串变量分配4个字节，在这个存储单元中，并不是直接存放字符串本身，而是存放字符串的地址。在本例中，就是把字符串"Zhang"的地址存放在name[0],把字符串Li”的地址存放在name[1],把字符串Fn"的地址存放在name[2]…在字符串变量中存放的是字符串的指针（字符串的地址）。</p>
</li>
<li>
<p>关于C++中string类型的字符串是否以‘\0’，结尾？</p>
<ul>
<li>
<p>今天在带大一学生C++上机时，涉及到个string类型的字符串是否以’\0’结尾的问题，本来我很坚定stig类型结尾并没有’\0’,C风格的字符数组才会那样。但是程序运行结果却说明string类型的字符串后面确实有’\0’。</p>
<ul>
<li>
<p>是否输出‘\0’跟编译器类型有关</p>
<div><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
   <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    string str=<span class="hljs-string">"hello"</span>;
    str[<span class="hljs-number">3</span>]=<span class="hljs-string">'\0'</span>;
    cout&lt;&lt;str&lt;&lt;endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>
</li>
<li>
<p>输出结果：hel o</p>
<div><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-type">int</span> main（）{
    <span class="hljs-type">char</span> str[<span class="hljs-number">6</span>]=<span class="hljs-string">"hello"</span>;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>,str);
    str[<span class="hljs-number">3</span>]=<span class="hljs-string">'\0'</span>;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>,str);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>
</li>
<li>
<p>输出结果 ：hel</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>应该明白了点什么！在C<ins>中0’不能作为识别string类字符串的结尾，但C中是以0’结尾。其实C</ins>-string类也不需要识别结尾，因为你需要用到的C++的函数库基本都帮你解决了。</p>
</li>
</ul>
</div>
      </article>
    </div>
  <script src="/_markdown_plugin_assets/mermaid/mermaid.min.js"></script>
<script src="/_markdown_plugin_assets/mermaid/mermaid_render.js"></script></body>
</html>
